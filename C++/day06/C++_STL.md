# C++标准库（STL）
## 一、简介
### 1.概述
&ensp;&ensp;&ensp;&ensp;标准模版库STL（Standard Template Library），是C++标准库的一部分，不需要单独安装，只需要`#include`头文件。
C++ 对模板（Template）支持得很好，STL就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。    
&ensp;&ensp;&ensp;&ensp;STL是由Alexander Stepanov和Meng Lee在90年代初期于惠普实验室开发完成的。它起初是作为一种尝试，为C++引入一种更加通用且高效的方式来处理常见的数据结构和算法。之后，STL成为了C++标准库的一部分，广泛应用于现代C++ 编程中。    
STL的主要特点包括：   
* **高效：** 它为开发者提供了经过优化的数据结构和算法，减少了手动编写和调试复杂代码的工作量。
* **泛型编程：** STL以模板为基础，可以处理不同的数据类型而无需重复编写相同逻辑。
* **可复用性强：** STL的组件被广泛应用于各种C++项目中，它让开发者能够以极少的代码实现强大的功能。    

STL的开发遵循了以下几项重要原则：    
1. **泛型编程：** 通过模板机制实现与数据类型无关的编程。
2. **算法与数据结构分离：** 算法和数据结构相互独立，可以互相组合使用。
3. **开放性：** 用户可以通过模板参数实现定制化的数据结构和算法。   

### 2.组件
STL包含以下六大核心组件：    
* **容器（Containers）：** 提供各种数据结构的实现，如向量（vector）、列表（list）、队列（queue）等。
* **迭代器（Iterators）：** 为容器提供一种通用的方式来遍历和操作其中的元素。
* **算法（Algorithms）：** 包括常见的排序、查找、修改等操作，如`sort()`、`find()`等。
* **函数对象（Function Objects）：** 允许通过重载`operator()`定义自定义的函数行为。
* **配接器（Adapters）：** 对现有的数据结构或算法进行调整，使它们具备新的行为，如`stack`、`queue`等。
* **分配器（Allocators）：** 负责内存的分配与管理，为容器提供灵活的内存管理机制。

## 二、版本
1. **原始版本（HP版本）**    
&ensp;&ensp;&ensp;&ensp;Alexander Stepanov、Meng Lee在惠普实验室完成的原始版本，本着开源精神，他们声明允许任何人任意运用、拷贝、修改、传播、商业使用这些代码，无需付费。唯一的条件就是也需要向原始版本一样做开源使用。    
2. **P.J.版本**      
&ensp;&ensp;&ensp;&ensp;由P.J.Plauger开发，继承自HP版本，被Windows Visual C++采用，不能公开或修改，缺陷：可读性比较低，符号命名比较怪异。      
3. **RW版本**       
&ensp;&ensp;&ensp;&ensp;由Rouge Wage公司开发，继承自HP版本，被C++ Builder采用，不能公开或修改，可读性一般。    
4. **SGI版本**    
&ensp;&ensp;&ensp;&ensp;由Silicon Graphics Computer Systems,Inc公司开发，继承自HP版本。被GCC(Linux) 采用，可移植性好，可公开、修改甚至贩卖，从命名风格和编程 风格上看，阅读性非常高。

## 三、容器
### 1.简介
&ensp;&ensp;&ensp;&ensp;在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。    
&ensp;&ensp;&ensp;&ensp;经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在细节上有所出入。STL容器就为我们提供了这样的方便，它允许我们重复利用已有的实现构造自己的特定类型下的数据结构，通过设置一些模版类，STL容器对最常用的数据结构提供了支持，这些模板的参数允许我们指定容器中元素的数据类型，可以将我们许多重复而乏味的工作简化。    
### 2.组成
&ensp;&ensp;&ensp;&ensp;**容器部分主要由头文件`<vector>`、`<list>`、`<deque>`、`<set>`、`<map>`、`<stack>`和`<queue>`组成。**   
&ensp;&ensp;&ensp;&ensp;对于常用的一些容器和容器适配器（可以看作由其它容器实现的容器），可以通过下表总结一下它们和相应头文件的对应关系：   
* **向量（vector）：** 连续存储的元素`<vector>`  
* **列表（list）：** 由节点组成的双向链表，每个结点包含着一个元素`<list>`  
* **双队列（deque）：** 连续存储的指向不同元素的指针所组成的数组`<deque>`  
* **集合（set）：** 由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序`<set>` 
* **多重集合（multiset）：** 允许存在两个次序相等的元素的集合`<set>`  
* **栈（stack）：** 后进先出的值的排列`<stack>`  
* **队列（queue）：** 先进先出的执的排列`<queue>`  
* **优先队列（priority_queue）：** 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列`<queue>`  
* **映射（map）：** 由`{键，值}`对组成的集合，以某种作用于键对上的谓词排列`<map>`  
* **多重映射（multimap）：** 允许键对有相等的次序的映射`<map>`

## 四、算法
&ensp;&ensp;&ensp;&ensp;大家都能取得的一个共识是函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——你可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。    
&ensp;&ensp;&ensp;&ensp;STL提供了大约100个实现算法的模版函数，比如算法`for_each`将为指定序列中的每一个元素调用指定的函数，`stable_sort`以你所指定的规则对序列进行稳定性排序等等。这样一来，只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能并大大地提升效率。    
&ensp;&ensp;&ensp;&ensp;**算法部分主要由头文件`<algorithm>`、`<numeric>`和`<functional>`组成。**    
* `<algorithm>`是所有STL头文件中最大的一个，它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。   
* `<numeric>`体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。   
* `<functional>`中定义了一些模板类，用以声明函数对象。
